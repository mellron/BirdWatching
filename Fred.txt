using System;
using System.IO;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Threading.Tasks;
using Microsoft.Extensions.Caching.Memory;

public class UserProfileImageService
{
    private readonly IMemoryCache _cache;
    private readonly HttpClient _httpClient;

    public UserProfileImageService(IMemoryCache cache, HttpClient httpClient)
    {
        _cache = cache;
        _httpClient = httpClient;
    }

    public async Task<byte[]> GetUserProfileImageAsync(string userId, string accessToken)
    {
        if (_cache.TryGetValue(userId, out CachedImage cachedImage))
        {
            // If the image is cached, use the ETag to check if it has changed
            var requestMessage = new HttpRequestMessage(HttpMethod.Get, $"https://graph.microsoft.com/v1.0/users/{userId}/photo/$value");
            requestMessage.Headers.Authorization = new AuthenticationHeaderValue("Bearer", accessToken);
            requestMessage.Headers.IfNoneMatch.Add(new EntityTagHeaderValue(cachedImage.ETag));

            var response = await _httpClient.SendAsync(requestMessage);

            if (response.StatusCode == System.Net.HttpStatusCode.NotModified)
            {
                // Return the cached image if it hasn't changed
                return cachedImage.ImageData;
            }
            else if (response.IsSuccessStatusCode)
            {
                // Update the cache if the image has changed
                var imageData = await response.Content.ReadAsByteArrayAsync();
                var eTag = response.Headers.ETag?.Tag;

                _cache.Set(userId, new CachedImage { ImageData = imageData, ETag = eTag }, TimeSpan.FromHours(24));

                return imageData;
            }
        }
        else
        {
            // Fetch and cache the image if not already cached
            var response = await _httpClient.GetAsync($"https://graph.microsoft.com/v1.0/users/{userId}/photo/$value");

            if (response.IsSuccessStatusCode)
            {
                var imageData = await response.Content.ReadAsByteArrayAsync();
                var eTag = response.Headers.ETag?.Tag;

                _cache.Set(userId, new CachedImage { ImageData = imageData, ETag = eTag }, TimeSpan.FromHours(24));

                return imageData;
            }
        }

        return null;
    }
}

public class CachedImage
{
    public byte[] ImageData { get; set; }
    public string ETag { get; set; }
}
